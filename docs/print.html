<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>A Trig-less Line of Sight Algorithm in Two Dimensions</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="Introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="Problem.html">The Problem</a></li><li class="chapter-item expanded affix "><a href="Rays.html">Sending out Rays</a></li><li class="chapter-item expanded affix "><a href="Angle.html">Sorting by Angle</a></li><li class="chapter-item expanded affix "><a href="Final.html">Finding Intersection Points</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">A Trig-less Line of Sight Algorithm in Two Dimensions</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="a-trig-less-line-of-sight-algorithm-in-two-dimensions"><a class="header" href="#a-trig-less-line-of-sight-algorithm-in-two-dimensions">A Trig-less Line of Sight Algorithm in Two Dimensions</a></h1>
<p><img src="./images/example.png" alt="Line of Sight Example" title="An example of what we are trying to do" /></p>
<p>It is common when simulating two-dimensional worlds (i.e. for video games) to want to determine line of sight from a specific point \(P\). That is, we'd like to find (a reasonable approximation to) the set of points \(Q\) such that the line \(\vec{PQ}\) does not pass through any solid objects. There are a few great articles that already talk about various approaches to this problem. In particular, the three linked below in the references section were used in various capacities during the formulation of the approach given here.</p>
<p>There are two theoretical complaints one might raise about the existing implementations. Firstly, one method purposefully excludes small slices of area that should be marked as visible near corners of wall segments. Secondly, they often feature (potentially) expensive operations such as (inverse) trigonometric functions or square roots, and the explanations of portions of the algorithm can lack intuition. In practice, these generally run quickly enough for what we need. Just because a given operation is expensive in theory doesn't mean that an alternate approach avoiding it will be faster in practice. Additionally, close enough is generally good enough for most use cases. All that being said, however, it is still worthwhile to see what can be done to address these concerns.</p>
<p>As such, we give an algorithm here which we attempt to explain in straightforward fashion using vectors. It only uses the operations of basic arithmetic: addition, subtraction, multiplication, and a few divisions. This is intended more as an exercise in using vectors rather than any attempts to create production ready code. Familiarity with vector basics such as vector addition, subtraction, and the dot product will be necessary. I recommend that serious projects use one of the algorithms listed in the references, as they are likely to be more battle-tested and stable. Here we do not handle floating point errors with much care, and we could signifcantly improve how we sort and iterate through structures.</p>
<p>The <a href="https://github.com/basstabs/2d-line-of-sight">repository</a> contains the code for our algorithm and a simple example application built using the <a href="https://crates.io/crates/ggez">ggez</a> crate. The code samples are written in Rust, however our code should be relatively language-agnostic for anyone with some experience with C-style syntax. </p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<p>Nicky Case: [<a href="https://ncase.me/sight-and-light/">1</a>]<br />
Sundaram Ramaswamy: [<a href="https://legends2k.github.io/2d-fov/design.html">2</a>]<br />
Amit Patel: [<a href="https://www.redblobgames.com/articles/visibility/">3</a>]</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h1>
<p>We are given a point \(P\) in space, an angle \(0&lt;\theta\leq\pi\), and a direction \(\vec{v}\). Our goal is to bound the region that can be seen from \(P\) while looking in the direction of \(\vec{v}\) with field of view \(\theta\). Our eyesight is not bounded by distance. (See [<a href="https://legends2k.github.io/2d-fov/design.html">2</a>] for a treatment where the distance is bounded.)</p>
<p><img src="./images/problem.png" alt="Problem Setup" title="An example problem" /></p>
<p>As our over-arching goal is to avoid using complex functions like trig functions or square roots, we will not actually use an angle and viewing direction to represent the problem. Instead, we shall store two vectors which bound the viewing region: \(\vec{l}\) (for &quot;lower&quot;) and \(\vec{u}\) (for &quot;upper&quot;), where the angle from \(\vec{l}\) to \(\vec{u}\) is larger than zero and no larger than \(\pi\).</p>
<p><img src="./images/problemvectors.png" alt="Problem Revision" title="The example redefined using u and l" /></p>
<p>For our algorithm to work, we need \(P\), \(\vec{l}\), \(\vec{u}\), and a list of line segments which represent all of the solid objects we can't see through. How you generate this list will depend on what shapes you are using to define your objects and which objects should and should not block visibility. For the sake of efficiency, it might be worthwhile to store all static line segments (such as those coming from walls) and update only dynamic line segments (such as those coming from characters) each frame.</p>
<h1 id="solution-outline"><a class="header" href="#solution-outline">Solution Outline</a></h1>
<p>We shall split the problem into three discrete steps.</p>
<ol>
<li>Send out rays from \(P\) which slice the viewing angle into triangles. </li>
<li>Sort the rays so that the ray defined via \(\vec{l}\) is the least and they increase by angle towards \(\vec{u}\).</li>
<li>Determine how far along each ray we should travel and use that to define the triangles whose union is the visible area.</li>
</ol>
<p>We will cover each step in its own section, first covering the math behind the code then walking through the code itself. We will also provide test code to verify that our math and code are behaving like we expect them to. In general we shall assume that our given vectors are non-zero while we are theory-crafting.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="sending-out-rays"><a class="header" href="#sending-out-rays">Sending out Rays</a></h1>
<p>As observed in our references, a naive initial approach to the line of sight problem is to simply cast out a large number of rays that slice our viewing area into small sections. We then measure the closest point where each ray intersects a line segment and connect the dots. </p>
<p><img src="./images/lotsofrays.png" alt="Casting Rays" title="Sending out a bunch of rays" /></p>
<p>For some use cases this approach might be good enough. However, it has a fatal flaw: the only way to improve its accuracy is to send out more and more rays. This increases the amount of computations we need to do drastically. </p>
<p>Fortunately, we can be more circumspect in how we send out rays. Instead of shooting them out indiscriminately, we shall throw one in the direction of \(\vec{l}\), one in the direction of \(\vec{u}\), and one in the direction of each endpoint of each line segment. </p>
<p><img src="./images/justendpoints.png" alt="Rays to Segment Endpoints" title="Only send rays to segment endpoints" /></p>
<p>While this may seem at first to introduce many more rays than we need, we will be rejecting all of the rays which do not lie within our viewing area, which eliminates a large number of unnecessary calculations. In the above example, eight of the twelve rays would be rejected, leaving us only six (four endpoint rays, \(\vec{l}\), and \(\vec{u}\)) we need to perform computations with. This is the same number of rays as in the naive example shown above, but with much greater accuracy.</p>
<p>To do this, we need to be able to tell whether or not a ray generated in this manner is within our viewing area. If it isn't, then we should not add it to our list. The most straightforward way to do this would be to measure the angle of each ray, and determine if its angle is between the angles of \(\vec{l}\) and \(\vec{u}\). However, our goal is to implement a line of sight algorithm without resorting to expensive operations like arctangent, so we'll handle this exclusion using vectors instead.</p>
<h2 id="rejecting-rays"><a class="header" href="#rejecting-rays">Rejecting Rays</a></h2>
<p>We want to use vectors to reject rays which live in the shaded region below.</p>
<p><img src="./images/sightregion.png" alt="Sight Region" title="Region between u and l" /></p>
<p>This region is the combination of two half-planes: the half-plane \(L\), which is all of the points to the right of the line defined by \(\vec{l}\), and the half-plane \(U\), which is all the points to the left of the line defined by \(\vec{u}\).</p>
<p><img src="./images/ulhalfplanes.png" alt="U and L" title="U and L" /></p>
<p>If a ray lies in either one of these half-planes, then we want to exclude it. We can use <i>normal</i> vectors to do this. A normal vector \(\hat{n}\) of a line defined via a vector \(\vec{n}\) is a vector which is perpendicular to the line, i.e. such that \(\hat{n}\cdot\vec{n} = 0\). </p>
<blockquote>
<p>This is analgous to the normal vector of a plane in three dimensions.</p>
</blockquote>
<p>Each line has two normal directions: the first, \(\hat{n}_{CCW}\), is obtained by rotating \(\vec{n}\) by \(\frac{\pi}{2}\) in the counterclockwise direction, and the other, \(\hat{n}_{CW}\), is obtained by rotating in the same amount in the clockwise direction. Any vector \(\vec{a}\) to the left of the line defined by \(\vec{n}\) will satisfy \(\vec{a}\cdot\hat{n}_{CCW}&gt;0\), and any vector \(\vec{b}\) to the right of the line defined by \(\vec{n}\) will satisfy \(\vec{b}\cdot\hat{n}_{CW}&gt;0\).</p>
<p><img src="./images/normalvectors.png" alt="Normal Vectors" title="Normal vectors for a given line" /></p>
<p>We can use this to reject the rays outside of our desired region. Given a vector \(\vec{r}\) representing one of our potential rays, we will compute \(\hat{u}_{CCW}\cdot\vec{r}\) and \(\hat{l}_{CW}\cdot\vec{r}\). If the first quantity is positive, then we know \(\vec{r}\) is inside \(U\). If the second quantity is positive, then we know \(\vec{r}\) is inside \(L\). In either case, it is not in the region we are looking for and we exclude it from our search. </p>
<p><img src="./images/applyingnormalvectors.png" alt="Applying Normal Vectors" title="Using normal vectors to limit our field of view" /></p>
<blockquote>
<p>For this to work, it is important that the angle between \(\vec{l}\) and \(\vec{u}\) is no larger than \(\pi\). However, we can process angles larger than \(\pi\) by applying this process to the complement angle and negating the result.</p>
</blockquote>
<p>The careful reader might have an objection to this process: rotating vectors sounds like trigonometry. Fortunately, as we're only rotating by right angles, we can avoid using any trig whatsoever! Given \(\vec{n}=\langle p,q\rangle\), we can compute the normal vectors via \(\hat{n}_{CCW}=\langle-q,p\rangle\) and \(\hat{n}_{CW}=\langle q,-p\rangle\). </p>
<blockquote>
<p>The skeptical reader can verify these facts using rotation matrices or by thinking of vectors as complex numbers and performing multiplication by \(i\) and \(-i\) respectively.</p>
</blockquote>
<h2 id="putting-this-into-practice"><a class="header" href="#putting-this-into-practice">Putting This Into Practice</a></h2>
<p>Below is the actual code that handles this ray rejection  process. <code>Point</code> is a simple struct with floating point values for its components <code>x</code> and <code>y</code>. We use this struct to represent both points in space and vectors. The <code>ray_between</code> function is a member of this struct which checks if the vector is between the provided values for <code>upper</code> and <code>lower</code>. <code>FLOATING_POINT_ERROR</code> should be thought of as basically zero. </p>
<blockquote>
<p>Floating point comparisons are a notoriously fickle issue best avoided by allowing for small amounts of error, which is why we do not compare to <code>0.0</code>. We have defined <code>FLOATING_POINT_ERROR</code> to be <code>0.0001</code>, although there is no specific rational behind this compared to other arbitrary values like <code>0.001</code> or <code>0.00001</code>. </p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	//Assumes the angle from lower to upper is less than pi. Swap lower and upper and negate it for larger angles
    //Returns false if self is not between lower and upper, true if it is
	pub fn ray_between(&amp;self, lower: Point, upper: Point) -&gt; bool
	{

		//Dot product of upper rotated ccw by pi/2
		let upper_component = self.y * upper.x - self.x * upper.y;

		if upper_component &gt; FLOATING_POINT_ERROR
		{

			return false;

		}

		//Dot product of lower rotated cw by pi/2
		let lower_component = self.x * lower.y - self.y * lower.x;

		if lower_component &gt; FLOATING_POINT_ERROR
		{

			return false;

		}

		return true;

	}
<span class="boring">}
</span></code></pre></pre>
<p>The only pieces of this code that might cause some confusion are the dot product calculations. Rather than adding overhead by allocating new <code>Point</code>s for the normal vectors and calling the dot product function on them, we perform the calculations manually to save time. This is done using the characterization of the normal vectors described in the last paragraph of the previous section.</p>
<p>We write some unit tests to verify that our code is doing what we want.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	#[test]
	fn ray_between()
	{

		let ray1 = Point { x: 2.5, y: 0.0 };
		let ray2 = Point { x: 0.0, y: 1.0 };
		let ray3 = Point { x: -1.0, y: 2.0 };
		let ray4 = Point { x: -1.0, y: -1.1 };
		let ray5 = Point { x: 3.7, y: -2.0 };
		let ray6 = Point { x: -2.0, y: 0.0 };
		let ray7 = Point { x: 0.0, y: -30.0 };
		let ray8 = Point { x: 10.0, y: 1.0 };

		assert!(ray8.ray_between(ray1, ray2));
		assert!(ray6.ray_between(ray3, ray4));
		assert!(ray5.ray_between(ray7, ray1));
		assert!(ray4.ray_between(ray3, ray5));

		assert!(!ray3.ray_between(ray1, ray2));
		assert!(!ray1.ray_between(ray3, ray4));
		assert!(!ray2.ray_between(ray7, ray1));
		assert!(!ray8.ray_between(ray3, ray5));

	}
<span class="boring">}
</span></code></pre></pre>
<p>We now have everything we need to handle the first section of our line of sight algorithm.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use super::space::{Point, Segment, Triangle};
</span><span class="boring">
</span><span class="boring">pub fn generate_line_of_sight(location: Point, upper: Point, lower: Point, segments: &amp;Vec&lt;Segment&gt;) -&gt; Vec&lt;Triangle&gt;
</span><span class="boring">{
</span><span class="boring">
</span>    let mut rays: Vec&lt;Point&gt; = Vec::new();
	rays.push(lower);
	rays.push(upper);

	//Collect the rays we need to project
	for segment in segments.iter()
	{

		let ray = segment.start - location;

		if ray.ray_between(lower, upper)
		{

			rays.push(ray);

		}

        let ray = segment.end - location;

        if ray.ray_between(lower, upper)
        {

            rays.push(ray);

        }

	}
<span class="boring">
</span><span class="boring">    //Sort the rays from lower to upper
</span><span class="boring">	Point::sort_from_angle(&amp;mut rays, lower);
</span><span class="boring">    //
</span><span class="boring">	//Actually create the triangles
</span><span class="boring">	let mut line_of_sight: Vec&lt;Triangle&gt; = Vec::new();
</span><span class="boring">
</span><span class="boring">	for i in 0..rays.len()-1
</span><span class="boring">	{
</span><span class="boring">
</span><span class="boring">		let mut shortest_current = 0.0;
</span><span class="boring">		let mut shortest_next = 0.0;
</span><span class="boring">
</span><span class="boring">		for segment in segments.iter()
</span><span class="boring">		{
</span><span class="boring">
</span><span class="boring">			let cast_current = segment.raycast(location, rays[i]);
</span><span class="boring">			let cast_next = segment.raycast(location, rays[i + 1]);
</span><span class="boring">
</span><span class="boring">			if cast_current.is_some() &amp;&amp; cast_next.is_some() &amp;&amp; (shortest_current == 0.0 || cast_current.unwrap() &lt; shortest_current)
</span><span class="boring">			{
</span><span class="boring">
</span><span class="boring">				shortest_current = cast_current.unwrap();
</span><span class="boring">				shortest_next = cast_next.unwrap();
</span><span class="boring">
</span><span class="boring">			}
</span><span class="boring">
</span><span class="boring">		}
</span><span class="boring">
</span><span class="boring">		line_of_sight.push(Triangle::new(location, location + rays[i].scale(shortest_current), location + rays[i + 1].scale(shortest_next)));
</span><span class="boring">
</span><span class="boring">	}
</span><span class="boring">
</span><span class="boring">    return line_of_sight;
</span><span class="boring">
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>We create a new vector (Rust's version of a resizable array) to store our rays in, then add <code>upper</code> and <code>lower</code> to it. From here, we iterate over each <code>segment</code> in the vector of <code>Segement</code>s which is passed into the function. <code>Segment</code> is a struct simply containing a <code>start</code> <code>Point</code> and an <code>end</code> <code>Point</code>. For each <code>segment</code>, we generate a ray between our location and both endpoints. We use <code>ray_between</code> to only accept rays which are between <code>upper</code> and <code>lower</code> in our collection.</p>
<p>Now we're ready to move on to the second part of our algorithm: sorting this collection of rays by angle.</p>
<h2 id="potential-improvements"><a class="header" href="#potential-improvements">Potential Improvements</a></h2>
<ol>
<li>If your line segments define a sensible collection of closed polygons, then we can skip the second ray portion because each point should be the beginning of some line segment.</li>
<li>Before adding rays to our collection, we could additionally check to ensure that we are not adding in multiple rays which point in the same direction, as these will be redundant.</li>
</ol>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="sorting-by-angle"><a class="header" href="#sorting-by-angle">Sorting by Angle</a></h1>
<p><img src="./images/unsorted.png" alt="Unsorted list of rays" title="Our collection of rays with their indices, unsorted" /></p>
<p>At this point, we've created a collection of rays emanating from \(P\), all of which lie within our viewing angle. Our goal will be to find where these rays intersect with the line segments blocking our view, and then connect the adjacent intersection points to create a sequence of triangles which represent our field of view. To do this, we'll need to sort our collection of rays via increasing angle so that we'll know which rays are neighbors.</p>
<p><img src="./images/sorted.png" alt="Sorted list of rays" title="Our collection of rays with their indices, now sorted" /></p>
<h2 id="sorting-by-vector-components"><a class="header" href="#sorting-by-vector-components">Sorting by Vector Components</a></h2>
<p>We're going to use dot products to avoid computing angles. Recall that, given two vectors \(\vec{n}\) and \(\vec{m}\), the component of \(\vec{n}\) in the direction of \(\vec{m}\) is given by \(\frac{\vec{n}\cdot\vec{m}}{|\vec{m}|}\).</p>
<p><img src="./images/projection.png" alt="Vector projection" title="An example of vector projection" /></p>
<p>Consider two of our rays defined by vectors \(\vec{a}\) and \(\vec{b}\), which we know lie between \(\vec{l}\) and \(\vec{u}\). As such, we kow that both the angle \(\theta_a\) between \(\vec{a}\) and \(\vec{l}\) and the angle \(\theta_b\) between \(\vec{b}\) and \(\vec{l}\) does not exceed \(\pi\) since the angle between \(\vec{l}\) and \(\vec{u}\) does not exceed \(\pi\). If all of our rays are defined by unit vectors, i.e. have length \(1\), we know that \(\theta_a\) is larger than \(\theta_b\) if and only if the component of \(\vec{a}\) in the direction of \(\vec{l}\) is <em>smaller</em> than the component of \(\vec{b}\) in the direction of \(\vec{l}\). In other words, we can sort unit vectors by increasing angle if we sort by <em>decreasing</em> components.</p>
<p><img src="./images/unit_vectors.png" alt="Unit vectors" title="Comparing unit vector components" /></p>
<blockquote>
<p>We can extend this for viewing angles greater than \(\pi\) by also considering the components along \(\hat{b}_{CCW}\). All of the rays with positive components along the normal vector come first and are sorted as described above. Then we include the rays with negative components along the normal vector, which need to be sorted in reverse. (That is, increasing components along \(\vec{l}\) correspond to increasing angles once we pass the angle \(\pi\).)</p>
</blockquote>
<p>Unfortunately, most of the time our rays will not be given by unit vectors. We could compute the unit vectors, but that would require that we compute the inverse square root of the length. We could use the notorious (and notoriously opaque) <a href="https://en.wikipedia.org/wiki/Fast_inverse_square_root">Fast Inverse Square Root Function</a>, but we shall instead use algebra to come up with a simpler solution for the sake of clarity. Let's write down the inequality we want to check:
\[\frac{\vec{a}\cdot\vec{l}}{|\vec{a}||\vec{l}|}&gt;\frac{\vec{b}\cdot\vec{l}}{|\vec{b}||\vec{l}|}\]
Here the factors of \(|\vec{a}|\) and \(|\vec{b}|\) in the denominators come from getting the components of the unit vectors in the direction of \(\vec{a}\) and \(\vec{b}\), not of \(\vec{a}\) and \(\vec{b}\) themselves. We can cancel \(|\vec{l}|\), leaving us with
\[\frac{\vec{a}\cdot\vec{l}}{|\vec{a}|}&gt;\frac{\vec{b}\cdot\vec{l}}{|\vec{b}|}\]
We multiply to rewrite this as
\[(\vec{a}\cdot\vec{l})|\vec{b}|&gt;(\vec{b}\cdot\vec{l})|\vec{a}|\]
Now, we can apply a common trick: \(n &gt; m\) if and only if \(n|n| &gt; m|m|\). This is because the function \(y=x|x|=sign(x)*x^2\) flips the left half of the parabola \(y=x^2\) upside down to make it an increasing function. Thus, we can now consider the inequality
\[(\vec{a}\cdot\vec{l})*|\vec{a}\cdot\vec{l}|*|\vec{b}|^2&gt;(\vec{b}\cdot\vec{l})*|\vec{b}\cdot\vec{l}|*|\vec{a}|^2\]
This is something we can represent in code using just addition and multiplication.</p>
<h2 id="putting-this-into-practice-1"><a class="header" href="#putting-this-into-practice-1">Putting This Into Practice</a></h2>
<p>We can calculate these quantities quite easily. Given <code>lower</code> as a <code>Point</code> as well as two <code>Point</code>s <code>a</code> and <code>b</code> that we wish to compare, we can write the following:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>			//We want to order by angle from lower, which is the same as reverse ordering by normalized projections along lower
			//We do some algebra to avoid computing square roots for the normalization, i.e. a dot L/|a|&gt;b dot L/|b| if and only if
			// a dot L*|a dot L|*|b|^2 &gt; b dot L * |b dot L| * |a|^2
			let a_dot_l = lower.dot(a);
			let lhs = a_dot_l.abs() * a_dot_l * (b.x * b.x + b.y * b.y);

			let b_dot_l = lower.dot(b);
			let rhs = b_dot_l.abs() * b_dot_l * (a.x * a.x + a.y * a.y);
<span class="boring">}
</span></code></pre></pre>
<p>Comparing these two values and using that to sort our list of rays will be language dependent. In Rust, the <code>Vec</code> type includes the convenient <code>sort_by</code> and <code>sort_unstable_by</code> (generally the faster of the two)  methods. These allow us to pass a closure which defines an ordering on the elements for us, and the <code>Vec</code> will then sort itself according to that ordering. We'll define an associated method for the <code>Point</code> struct to do just this using the above calculations.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	//Works so long as all represented angles are between lower and lower+pi
	pub fn sort_from_angle(rays: &amp;mut Vec&lt;Point&gt;, lower: Point)
	{

		rays.sort_unstable_by(|a, b|
		{

			//We want to order by angle from lower, which is the same as reverse ordering by normalized projections along lower
			//We do some algebra to avoid computing square roots for the normalization, i.e. a dot L/|a|&gt;b dot L/|b| if and only if
			// a dot L*|a dot L|*|b|^2 &gt; b dot L * |b dot L| * |a|^2
			let a_dot_l = lower.dot(a);
			let lhs = a_dot_l.abs() * a_dot_l * (b.x * b.x + b.y * b.y);

			let b_dot_l = lower.dot(b);
			let rhs = b_dot_l.abs() * b_dot_l * (a.x * a.x + a.y * a.y);
			return rhs.partial_cmp(&amp;lhs).unwrap();

		});

	}
<span class="boring">}
</span></code></pre></pre>
<p>Here we are given a list of <code>Point</code>s which represent our rays and a <code>Point</code> for <code>lower</code>. We declare the list as mutable so that we can sort it. Then we simply call <code>sort_unstable_by</code> with our custom closure. Notice that we return <code>rhs.partial_cmp(&amp;lhs)</code> as opposed to <code>lhs.partial_cmp(&amp;rhs)</code>. This is making Rust reverse the order relation between the two values as discussed above. </p>
<blockquote>
<p>The <code>&amp;</code> and <code>.unwrap()</code> in the above code is Rust specific and is not particularly relevant to our algorithm, just necessary minutiae to make the code compile.</p>
</blockquote>
<p>We again provide a test to double-check that our code works as expected.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	#[test]
	fn angle_sort()
	{

		let mut rays = vec![Point { x: 1.0, y: 1.0 }, Point { x: 0.0, y: 1.0 }, Point { x: 2.0, y: 4.0 }, Point { x: -1.0, y: 1.0 }, Point { x: 1.0, y: 0.2 } ];
		Point::sort_from_angle(&amp;mut rays, Point { x: 1.0, y: 0.0 });

		assert_eq!(rays, vec![Point { x: 1.0, y: 0.2 }, Point { x: 1.0, y: 1.0 }, Point { x: 2.0, y: 4.0 }, Point { x: 0.0, y: 1.0 }, Point { x: -1.0, y: 1.0 }]);

	}
<span class="boring">}
</span></code></pre></pre>
<p>Applying this code to our <code>generate_line_of_sight</code> algorithm is as simple as calling our associated sorting function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use super::space::{Point, Segment, Triangle};
</span><span class="boring">
</span><span class="boring">pub fn generate_line_of_sight(location: Point, upper: Point, lower: Point, segments: &amp;Vec&lt;Segment&gt;) -&gt; Vec&lt;Triangle&gt;
</span><span class="boring">{
</span><span class="boring">
</span><span class="boring">    let mut rays: Vec&lt;Point&gt; = Vec::new();
</span><span class="boring">	rays.push(lower);
</span><span class="boring">	rays.push(upper);
</span><span class="boring">
</span><span class="boring">	//Collect the rays we need to project
</span><span class="boring">	for segment in segments.iter()
</span><span class="boring">	{
</span><span class="boring">
</span><span class="boring">		let ray = segment.start - location;
</span><span class="boring">
</span><span class="boring">		if ray.ray_between(lower, upper)
</span><span class="boring">		{
</span><span class="boring">
</span><span class="boring">			rays.push(ray);
</span><span class="boring">
</span><span class="boring">		}
</span><span class="boring">
</span><span class="boring">        let ray = segment.end - location;
</span><span class="boring">
</span><span class="boring">        if ray.ray_between(lower, upper)
</span><span class="boring">        {
</span><span class="boring">
</span><span class="boring">            rays.push(ray);
</span><span class="boring">
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">	}
</span><span class="boring">
</span>    //Sort the rays from lower to upper
	Point::sort_from_angle(&amp;mut rays, lower);
<span class="boring">    //
</span><span class="boring">	//Actually create the triangles
</span><span class="boring">	let mut line_of_sight: Vec&lt;Triangle&gt; = Vec::new();
</span><span class="boring">
</span><span class="boring">	for i in 0..rays.len()-1
</span><span class="boring">	{
</span><span class="boring">
</span><span class="boring">		let mut shortest_current = 0.0;
</span><span class="boring">		let mut shortest_next = 0.0;
</span><span class="boring">
</span><span class="boring">		for segment in segments.iter()
</span><span class="boring">		{
</span><span class="boring">
</span><span class="boring">			let cast_current = segment.raycast(location, rays[i]);
</span><span class="boring">			let cast_next = segment.raycast(location, rays[i + 1]);
</span><span class="boring">
</span><span class="boring">			if cast_current.is_some() &amp;&amp; cast_next.is_some() &amp;&amp; (shortest_current == 0.0 || cast_current.unwrap() &lt; shortest_current)
</span><span class="boring">			{
</span><span class="boring">
</span><span class="boring">				shortest_current = cast_current.unwrap();
</span><span class="boring">				shortest_next = cast_next.unwrap();
</span><span class="boring">
</span><span class="boring">			}
</span><span class="boring">
</span><span class="boring">		}
</span><span class="boring">
</span><span class="boring">		line_of_sight.push(Triangle::new(location, location + rays[i].scale(shortest_current), location + rays[i + 1].scale(shortest_next)));
</span><span class="boring">
</span><span class="boring">	}
</span><span class="boring">
</span><span class="boring">    return line_of_sight;
</span><span class="boring">
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Finally, it is time to calculate where our rays intersect with our walls and form triangles to represent our line of sight.</p>
<h2 id="potential-improvements-1"><a class="header" href="#potential-improvements-1">Potential Improvements</a></h2>
<ol>
<li>It would probably be significantly more efficient to sort the rays as they are added to our collection. We have done it afterwards for ease of explanation.</li>
<li>It may be beneficial to use the mentioned Fast Inverse Square Root Function in place of the above algebra if we do not care about readability.</li>
</ol>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="finding-intersection-points"><a class="header" href="#finding-intersection-points">Finding Intersection Points</a></h1>
<p>Up to this point, we have used the terms vector and ray more or less interchangeably. This has been acceptable because thus far we have only cared about the direction of our rays. Now, however, we shall also need to care about how far our rays travel until they hit an obstacle, so we shall now make the distinction between the two clear. Given a vector \(\vec{v}\) and a point \(P\), the ray defined via \(\vec{v}\) at \(P\) is
\[P+t\vec{v},\ 0\leq t&lt;\infty\]
In other words, the ray is an &quot;infinite vector&quot; which is obtained by scaling \(\vec{v}\) by every positive real number. </p>
<p>Line segments, on the other hand, are finite pieces of lines contained between two points on the line. Given two points \(S\) (start) and \(E\) (end), we can represent the line segment \(\vec{SE}\) via
\[(1-s)S+sE,\ 0\leq s\leq 1\]
We want to figure out where (if anywhere) a given ray and a given line segment intersect.</p>
<h2 id="raycasting"><a class="header" href="#raycasting">Raycasting</a></h2>
<p>Checking rays for intersections is commonly known as raycasting, although this term is most commonly associated with its use in 3D graphics for determining which objects should be visible to a camera. Nonetheless, the principle is the same. The algebra below is nothing new, but we provide it for the sake of completeness. The algebra is not difficult, but it is symbolically intensive. It may be beneficial for some to skip to the code portion, as that is more readable.</p>
<p>We want to find an intersection point between a ray \(P+t\vec{v}\) and a line segment \((1-s)S+sE\). In other words, we want to compute \(0\leq s\leq 1\) and \(0\leq t&lt;\infty\) such that
\[P+t\vec{v}=(1-s)S+sE\]
As we have two unknowns, we need two equations to solve for both values. Fortunately, as our vectors are two-dimensional, we can represent this as
\[P_x+t\vec{v}_x=(1-s)S_x+sE_x\]
and
\[P_y+t\vec{v}_y=(1-s)S_y+sE_y\]
In other words, we simply set the components equal to one another.</p>
<p>First, we solve for \(t\) in terms of \(s\) in the obvious fashion
\[t=\frac{(1-s)S_x+sE_x-P_x}{\vec{v}_x}\text{ if }\vec{v}_x\neq0\]
and
\[t=\frac{(1-s)S_y+sE_y-P_y}{\vec{v}_y}\text{ if }\vec{v}_y\neq0\]
So long as \(\vec{v}\) is not the zero vector, then we will be able to solve for \(t\) given \(s\) using at least one of the above equations.</p>
<p>We plug in one of the above expressions for \(t\) in the other equation. We shall use the \(y\) equation and substitute it into the \(x\) equation. This gives us
\[P_x+\frac{(1-s)S_y+sE_y-P_y}{\vec{v}_y}*\vec{v}_x=(1-s)S_x+sE_x\]
We multiply through by \(\vec{v}_y\) to eliminate the denominator, yielding
\[P_x\vec{v}_y+(1-s)S_y\vec{v}_x+sE_y\vec{v}_x-P_y\vec{v}_x=(1-s)S_x\vec{v}_y+sE_x\vec{v}_y\]
Next, we combine the terms with an \(s\) on one side of the equality, and the ones without an \(s\) on the other:
\[sE_y\vec{v}_x+sS_x\vec{v}_y-sS_y\vec{v}_x-sE_x\vec{v}_y=S_x\vec{v}_y+P_y\vec{v}_x-P_x\vec{v}_y-S_y\vec{v}_x\]
So long as \(E_y\vec{v}_x+S_x\vec{v}_y-S_y\vec{v}_x-E_x\vec{v}_y\neq0\), we can factor out \(s\) from the left hand side and divide by this quantity to obtain
\[s=\frac{S_x\vec{v}_y+P_y\vec{v}_x-P_x\vec{v}_y-S_y\vec{v}_x}{E_y\vec{v}_x+S_x\vec{v}_y-S_y\vec{v}_x-E_x\vec{v}_y}\]</p>
<p>Notice that we can rewrite the denominator as
\[E_y\vec{v}_x+S_x\vec{v}_y-S_y\vec{v}_x-E_x\vec{v}_y=(E_y-S_y)\vec{v}_x+(E_x-S_x)(-\vec{v}_y)=(E-S)\cdot\hat{v}_{CCW}\]
Therefore, the denominator is zero exactly when \(E-S\) and \(\vec{v}\) are parallel. It is safe for us to ignore this case.</p>
<blockquote>
<p>We can ignore this case because our line segments are infinitesimally thin. If a line segment parallel to our vision blocks our vision, it only blocks an infinitesimally small line behind it which cannot be represented on screen. If it is part of a larger shape, then the adjacent, non-parallel edges will act with our algorithm to block line of sight for the whole shape.</p>
</blockquote>
<p>Solving for \(t\) is then a simple matter of plugging in the new value of \(s\) into our original equations for \(t\). This is relatively straightforward to code.</p>
<h2 id="putting-this-into-practice-2"><a class="header" href="#putting-this-into-practice-2">Putting This Into Practice</a></h2>
<p>Here is our complete raycasting algorithm.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	pub fn raycast(&amp;self, location: Point, ray: Point) -&gt; Option&lt;f32&gt;
	{

		//Ensure the ray can be raycast
		if ray.x == 0.0 &amp;&amp; ray.y == 0.0
		{

			panic!(&quot;Cannot raycast the zero vector&quot;);

		}

		let rise = self.end.y - self.start.y;
		let run = self.end.x - self.start.x;

		let denominator = rise * ray.x - run * ray.y;
		if denominator.abs() &lt; FLOATING_POINT_ERROR //The ray and the segment are parallel, so there is no intersection to find
		{

			return None;

		}

		let segment_param = (location.y * ray.x + self.start.x * ray.y - location.x * ray.y - self.start.y * ray.x) / denominator;
		if segment_param &lt; -FLOATING_POINT_ERROR || segment_param &gt; 1.0 + FLOATING_POINT_ERROR //The lines intersect outside the segment, so there is no intersection
		{

			return None;

		}

		let ray_param;
		if ray.x == 0.0
		{

			ray_param = (self.start.y - location.y + rise * segment_param) / ray.y;

		}
		else
		{

			ray_param = (self.start.x - location.x + run * segment_param) / ray.x;

		}

		if ray_param &lt; -FLOATING_POINT_ERROR //The opposite of the ray intersects the segment, not the ray itself
		{

			return None;

		}

		return Some(ray_param);

	}
<span class="boring">}
</span></code></pre></pre>
<p>We have defined <code>raycast</code> as a method on the <code>Segment</code> type. It returns an <code>Option&lt;f32&gt;</code>, which means we return a floating point number representing \(t\) in the above formulation if it exists, and nothing otherwise. First, we check to ensure that the given vector does not try to define the zero vector, as that does not determine a ray. Next, we compute the denominator of the above equation for \(s\). If it is zero, then we do not continue checking as our line segment and our ray are parallel. If it is not zero, then we compute <code>segment_param</code>, or \(s\), using the above equation. </p>
<p>If <code>segment_param</code> is less than \(0\) or greater than \(1\), this means that our ray hits the line through <code>start</code> and <code>end</code>, but not the line segment itself. In other words, there is no intersection. If it is between these two values, we use one of the two equations above to calculate <code>ray_param</code>, or \(t\). If <code>ray_param</code> is negative, then there is no intersection. If it is non-negative, then there is an intersection and we return <code>ray_param</code>.</p>
<blockquote>
<p>Notice that having <code>ray_param</code> allows us to calculate the point of intersection. We return the parameter rather than the point itself because we need to be able to sort the intersection points by how far away they are.</p>
</blockquote>
<p>As before, we provide some automated tests to ensure our code is working properly.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	#[test]
	fn raycast()
	{

		let segment1 = Segment::new(Point { x: 10.0, y: 0.0 }, Point { x: 0.0, y: 0.0 });
		let segment2 = Segment::new(Point { x: 0.0, y: 0.0 }, Point { x: 0.0, y: 10.0 });
		let segment3 = Segment::new(Point { x: 1.0, y: 9.0 }, Point { x: 2.0, y: 5.0});

		let cast1 = segment1.raycast(Point { x: 1.0, y: -1.0 }, Point { x: 0.0, y: 1.0 }).unwrap();
		let cast2 = segment2.raycast(Point { x: 3.0, y: 4.0 }, Point { x: -30.0, y: 0.0 }).unwrap();
		let cast3 = segment3.raycast(Point { x: 0.0, y: 9.0 }, Point { x: 1.0, y: -1.0 }).unwrap();

		assert_eq!(1.0, cast1);
		assert_eq!(1.0 / 10.0, cast2);
		assert_eq!(4.0 / 3.0, cast3);

		let cast4 = segment1.raycast(Point { x: 2.0, y: 0.0 }, Point { x: 1.0, y: 0.0 });
		let cast5 = segment2.raycast(Point { x: 1.0, y: 11.0 }, Point { x: -1.0, y: 0.0 });
		let cast6 = segment3.raycast(Point { x: 0.0, y: 9.0 }, Point { x: -1.0, y: 1.0 });

		assert!(cast4.is_none());
		assert!(cast5.is_none());
		assert!(cast6.is_none());

	}
<span class="boring">}
</span></code></pre></pre>
<h2 id="using-raycasting-to-finish-our-algorithm"><a class="header" href="#using-raycasting-to-finish-our-algorithm">Using Raycasting to Finish Our Algorithm</a></h2>
<p>Finally, we have all of the pieces necessary to finish our line of sight algorithm. Here is the last chunk of code:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use super::space::{Point, Segment, Triangle};
</span><span class="boring">
</span><span class="boring">pub fn generate_line_of_sight(location: Point, upper: Point, lower: Point, segments: &amp;Vec&lt;Segment&gt;) -&gt; Vec&lt;Triangle&gt;
</span><span class="boring">{
</span><span class="boring">
</span><span class="boring">    let mut rays: Vec&lt;Point&gt; = Vec::new();
</span><span class="boring">	rays.push(lower);
</span><span class="boring">	rays.push(upper);
</span><span class="boring">
</span><span class="boring">	//Collect the rays we need to project
</span><span class="boring">	for segment in segments.iter()
</span><span class="boring">	{
</span><span class="boring">
</span><span class="boring">		let ray = segment.start - location;
</span><span class="boring">
</span><span class="boring">		if ray.ray_between(lower, upper)
</span><span class="boring">		{
</span><span class="boring">
</span><span class="boring">			rays.push(ray);
</span><span class="boring">
</span><span class="boring">		}
</span><span class="boring">
</span><span class="boring">        let ray = segment.end - location;
</span><span class="boring">
</span><span class="boring">        if ray.ray_between(lower, upper)
</span><span class="boring">        {
</span><span class="boring">
</span><span class="boring">            rays.push(ray);
</span><span class="boring">
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">	}
</span><span class="boring">
</span><span class="boring">    //Sort the rays from lower to upper
</span><span class="boring">	Point::sort_from_angle(&amp;mut rays, lower);
</span><span class="boring">    //
</span>	//Actually create the triangles
	let mut line_of_sight: Vec&lt;Triangle&gt; = Vec::new();

	for i in 0..rays.len()-1
	{

		let mut shortest_current = 0.0;
		let mut shortest_next = 0.0;

		for segment in segments.iter()
		{

			let cast_current = segment.raycast(location, rays[i]);
			let cast_next = segment.raycast(location, rays[i + 1]);

			if cast_current.is_some() &amp;&amp; cast_next.is_some() &amp;&amp; (shortest_current == 0.0 || cast_current.unwrap() &lt; shortest_current)
			{

				shortest_current = cast_current.unwrap();
				shortest_next = cast_next.unwrap();

			}

		}

		line_of_sight.push(Triangle::new(location, location + rays[i].scale(shortest_current), location + rays[i + 1].scale(shortest_next)));

	}

    return line_of_sight;
<span class="boring">
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>The entire function can be viewed by unhiding the remaining lines with the eye icon above.</p>
</blockquote>
<p>We create a new collection to store the triangles that will represent our line of sight. We then loop through our rays, forming a triangle whose edges are the current ray, the next ray, and the closest line segment that they both hit.</p>
<blockquote>
<p>In Rust, we usually traverse a <code>Vec</code> type using an iterator rather than incrementing an index. In this case, though, we want easy access to the next item at every step and we don't want to do anything for the last ray, so we use the index to give ourselves control in a way that is more familiar to non-Rustaceans.</p>
</blockquote>
<p>To find the closest line segment they both intersect with, we loop over all of our line segments and find out how far the rays travel with the <code>raycast</code> function. We ignore the line segment if one of the rays does not intersect with it, or if they intersect but it is further away than some previous one. Once we've found the closest line segment, we form our triangle. It is worth noting that because our ray vectors are not unit vectors, the result of <code>raycast</code> will not be the distance away from our point: it will be the distance scaled by the length of the vector. As we only care about comparing whether one line segment is closer than another, though, this suffices.</p>
<p>Finally, we have created a collection of triangles which represents our line of sight.</p>
<p><img src="./images/final.png" alt="Final line of sight representation" title="Our line of sight represented as a list of triangles" /></p>
<p>Here is a low-quality GIF of this algorithm in action.</p>
<p><img src="./images/example.gif" alt="Line of Sight GIF" title="A gif showcasing an example of the algorithm in action." /></p>
<p>The example was created using the <a href="https://crates.io/crates/ggez">ggez</a> crate. Interested users can download the example from the <a href="https://github.com/basstabs/2d-line-of-sight">repository</a> and build it with cargo. The world is created in the <code>State::new</code> function inside main.rs if you are interested in modifying the example. At this time, the provided code is not a crate because there is nothing that I consider ready to use out of the box. You should use the provided code as inspiration to implement your own algorithm which is optimized for your specific use case.</p>
<h2 id="potential-improvements-2"><a class="header" href="#potential-improvements-2">Potential Improvements</a></h2>
<ol>
<li>In our <code>raycast</code> function, it is probably overkill to <code>panic</code> and halt program execution. We could just as easily return <code>None</code> or possibly make the function return a <code>Result&lt;f32&gt;</code> with coherent errors when there is no intersection.</li>
<li>One common technique in line of sight algorithms is to throw out extra rays very close to those which hit endpoints. (For example, as described in [<a href="https://ncase.me/sight-and-light/">1</a>]) This enables us to only raycast once per line segment as opposed to twice. We have ommitted this technique for the sake of accuracy, but it is likely faster and accurate enough for most use cases.</li>
<li>Additionally, we may be able to sort the line segments by their angle from our position in such a way that we needn't loop over all of them for each ray. Such a technique is discussed in [<a href="https://www.redblobgames.com/articles/visibility/">3</a>].</li>
</ol>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>Hopefully this has been helpful to some people. Suggestions for improving the descriptions or the code are much appreciated!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>
        
        

    </body>
</html>
